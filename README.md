# Формы и компоненты

## Field-компоненты и их настройки

Один и тот же параметр модели приложения может быть представлен полями ввода на разных формах. При этом, ему в общем случае будет нужна одна и та же валидация, одна и та же подпись, одни и те же дополнительные опции, маски и т.п. Возникла идея все эти настройки хранить в одном месте — в объекте **formFieldPresets** в одноимённом файле. Каждое поле **formFieldPresets** хранит настройки соответствующего параметра модели, имеющего поля на формах.

### Виды используемых компонентов

Технология использует компоненты трёх видов:

1. **Form-компонент** — компонент формы, которая является контейнером компонентов полей формы.
2. **Field-компонент**, который непосредственно устанавливается на форму и обеспечивает пользовательский ввод, загружаемый в соответствующий параметр модели.
3. **UI-компоненты** — "кирпичики", используемые для сборки Field-компонента (необязательно)

Используется несколько вариантов компонентов в зависимости от того, какого характера должен быть ввод — однострочный текст, многострочный текст, дата, число, денежная сумма, Select, Multiselect и т.п. Он может быть выбран из имеющихся:

*BooleanField.vue*,
*CheckboxBlockField.vue*,
*CheckboxBlockLightweightField.vue*,
*CheckboxField.vue*,
*CostField.vue*,
*DateField.vue*,
*DateIndicatorField.vue*,
*EditableListField.vue*,
*InputAutocompleteField.vue*,
*MultiSelectField.vue*,
*NumberField.vue*,
*NumberWithUnitsField.vue*,
*PasswordBaseField.vue*,
*PhoneField.vue*,
*PhotosUploadField.vue*,
*PhotoUploadField.vue*,
*RadioBlockField.vue*,
*SelectField.vue*,
*SelectMembershipPlanField.vue*,
*SelectPaymentMethodField.vue*,
*ServiceCheckboxField.vue*,
*TextAreaField.vue*,
*TextField.vue*,
*YearField.vue*,
*ZipCodeField.vue*.

Если ни один из этих компонентов не подходит, нужно создать новый компонент, и пополнить им этот список.

Каждый вариант **Field-компонента** отличается по функциональности взаимодействия с пользователем. Часть из этих вариантов использует html input, часть — выпадающий список, блок чекбоксов и т.п. Также есть отличия в настройках масок, и других технологий управления.

### Настройки Field-компонентов

Кроме настроек, связанных с характером вводимой величины, **Field-компонент** требует настроек, связанных с конкретным параметром модели. Например, нужно указать дату получения водительских прав. В этом случае будет использоваться **Field-компонент** *DateField*. При этом, он должен ограничить диапазон используемых дат только прошедшими датами. Напротив, для даты окончания срока действия прав допустимы только будущие даты.

**Field-компонент** настраивается под конкретный параметр модели с помощью 3-х уровней настроек:

1-й уровень — уровень по умолчанию, срабатывает, когда не указаны настройки на других уровнях. Этот уровень определён в самом компоненте. Такие настройки будут одинаковыми для всех полей, которые используют данный **Field-компонент**.

2-й уровень определён индивидуально для каждого параметра модели. Настройки этого уровня помещены в файл *components/form/data/formFieldPresets.ts* . При рендеринге **Field-компонент** обращается к этому файлу и берёт оттуда соответствующие настройки. Такие настройки будут одинаковыми для одного и того же параметра модели, размещённого на разных формах. Эти настройки имеют более высокий приоритет, чем настройки **Field-компонента** по умолчанию.

3-й уровень определён в свойствах самого **Field-компонента** . Иногда необходимо в поле формы, которое связано с параметром модели и размещается на нескольких формах, внести некоторые особенности, определяемые контекстом формы. Например, на форме регистрации в приложении в подписи для какого-то поля может помещаться дополнительная информация, которая оказывается избыточной на других формах, и показываться там не должна. В этом случае настройки передаются в свойствах самого **Field-компонента**, в частности, для указанного примера в свойствах поля будет указан атрибут label, который в других случаях можно опустить в расчёте на то, что он будет взят из файла *formFieldPresets.ts* . Такие "контекстные" настройки имеют наивысший приоритет.

### Ключи объекта formFieldPresets

В файле *formFieldPresets.ts* хранится объект настроек полей форм. Ключами объекта служат имена полей формы, соответствующие именам параметров модели. Эти имена-ключи прописываются в свойстве *name* **Field-компонента** . Такой подход работает в большинстве случаев, но при этом возможны конфликты имён, когда поля разных объектов модели имеют одинаковые имена. Кроме того, на формах могут использоваться поля, которые напрямую не связаны ни с каким параметром модели, но их настройки однотипны для разных форм, хотя имена полей при этом могут отличаться.

Для разрешения таких конфликтов используется технология служебных имён. В этом случае для получения настроек из *formFieldPresets.ts* в **Field-компоненте** вместо *name* задаётся свойство *serviceName*, которое уже не соответствует имени поля формы и выбирается разработчиком произвольно. **Field-компонент** будет искать настройки в файле *formFieldPresets.ts* по ключу, заданному в свойстве *serviceName* при его наличии. При этом поле *name* должно быть задано пресете, так как оно используется для формирования ID, размещаемых на элементах управления компонента.

Объект, найденный по ключу (*name* или *serviceName*), заданному в **Field-компоненте**, и будет пресетом, содержащим настройки этого компонента.

### Виды настроек Field-компонента

- Поле label, определяющее подпись для поля ввода.
- Настройки, определяющие отображение и поведение специфичные для каждого варианта компонента поля ввода — опции для блока чекбоксов, условия для определения доступности выбора дат и т.п.
- Настройки валидации, которые ниже рассматриваются более подробно.

## Настройки валидации

Для валидации полей форм используется модуль vuelidate. Настройка валидации определяется правилами (rules), которые подключены к полю формы. Используются как встроенные правила из модуля vuelidate, так и дополнительные, которые определяются в файле lib/validators.ts . Среди правил особое место занимает правило *required*, определяющее обязательность поля. Одно и то же поле, связанное с параметром модели, на одних формах может быть обязательным, а на других — нет. То есть, формы могут быть "строгими", на которых такие поля обязательны, и "нестрогими", на которых эти поля необязательны, при этом, другие правила валидации на этих формах остаются в силе — если уж значение вводится, то оно должно вводиться корректно.

Поэтому правило *required* не привязывается к настройкам **Field-компонента**. Оно автоматически подключается к полям при инициализации формы:

```typescript
  validations() {
    // Rules from formFieldPresets will be automatically added
    // to these fields from this list,
    // except for fields from the exclusions list.
    const fieldNames = Object.keys(this.form)

    // If the field does not need validation, or validation
    // is determined by conditions, write it in this list:
    const exclusions = ['faaCertificateNumber']

    const form = setStaticFormValidation(
      fieldNames,
      this.validateRequiredRule,
      exclusions,
    )

    // Define the validation rules by condition here:
    const hasFaaCertificateNumberValidationRules =
      formFieldPresets.faaCertificateNumber.validationRules

      form.faaCertificateNumber = { ...hasFaaCertificateNumberValidationRules }

    if (this.hasFaaCertificateNumber) {
      form.faaCertificateNumber.required = required
    }

    return { form }
  }
```

Правила валидации подключаются к полям формы в функции *setStaticFormValidation()* . Если какие-то поля не являются обязательными даже на строгих формах, они должны быть помещены в массив исключений *exclusions*. Также можно обычным образом отдельно определить для полей правила, подключаемые по условию. В этом случае такие поля также помещаются в *exclusions*.

В некоторых случаях вместо *required* нужно использовать другое правило, которое аналогично по смыслу, но работает немного иначе. Например, в блоке чекбоксов должно быть хоть что-то выбрано (правила *hasElements*, *hasSelected*, *multiselectNotEmpty* и аналогичные). В этом случае нужно указать в пресете поле *asRequired* объект с соответствующим правилом, заменяющим *required*:

```typescript
    asRequired: { hasSelected },
```

Прочие правила валидации подключаются к **Field-компоненту** с помощью поля *validationRules* в пресете:

```typescript
    validationRules: {
      minLength: minLength(3),
      maxLength: maxLength(20),
    },
```

## Механизм расстановки ID на управляющих элементах

Для тестирования управляющие элементы страницы должны иметь уникальные ID. ID элемента задаётся в CamelCase и формируется по следующей схеме:

```typescript
formId + name + [Названия, связанные с внутренней структурой компонента] + <Название или/и назначение элемента>
```

- *formId* задаётся, как поле данных компонента и должно соответствовать имени компонента.

- *Названия, связанные со структурой* используются, если компонент образует сложную структуру, например, выпадающий список. В этом случае пункты списка добавят 'Item' + индекс в свой ID.

- *Название или/и назначение элемента* — в большинстве случаев здесь помещается название элемента — *Button*, *Input* и т.п. В случае, если компонент имеет несколько однотипных элементов, после названия элемента следует имя, с которым связан этот элемент. Например, в меню выбора даты ID на кнопке года оканчивается на *ButtonYear*. Для дней календарной сетки ID оканчивается на DateRow2Col4. Это окончание содержит координаты ячейки в таблице выпадающего календаря.

ID формируется путём проброса свойств от формы, передающей formId через **Field-компонент**, который к formId добавляет name и пробрасывает эту строку-заготовку для ID в дочерние UI-компоненты, если они есть. В любом случае ID окончательно формируются и расставляются в шаблоне того компонента, в котором используются эти элементы. Исключение составляют сторонние компоненты, например, data-picker, шаблон или рендер-функция которых недоступна. В этом случае для таких компонентов приходится расставлять ID на управляющих элементах путём манипуляции с DOM, опираясь на стили или какие-то другие атрибуты для их идентификации.
