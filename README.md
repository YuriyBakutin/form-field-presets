# form-field-presets

Технология настроек полей ввода формы с помощью файла предустановленных параметров (пресетов)

Один и тот же параметр модели приложения может быть представлен полями ввода на разных формах. При этом, ему в общем случае будет нужна одна и та же валидация, одна и та же подпись, одни и те же дополнительные опции, маски и т.п. Возникла идея все эти настройки хранить в одном месте — в объекте **formFieldPresets** в одноимённом файле. Каждое поле **formFieldPresets** хранит настройки соответствующего параметра модели, имеющего поля на формах.

## Виды используемых компонентов

Технология использует компоненты трёх видов:

1. **Form-компонент**, который является контейнером компонентов полей формы.
2. **Field-компонент**, который непосредственно устанавливается на форму и обеспечивает пользовательский ввод, загружаемый в соответствующий параметр модели.
3. **UI-компоненты** — "кирпичики", используемые для сборки Field-компонента (необязательно)

Используется несколько вариантов компонентов в зависимости от того, какого характера должен быть ввод — однострочный текст, многострочный текст, дата, число, денежная сумма, Select, Multiselect и т.п. Он может быть выбран из имеющихся:

*BooleanField.vue*,
*CheckboxBlockField.vue*,
*CheckboxBlockLightweightField.vue*,
*CheckboxField.vue*,
*CostField.vue*,
*DateField.vue*,
*DateIndicatorField.vue*,
*EditableListField.vue*,
*InputAutocompleteField.vue*,
*MultiSelectField.vue*,
*NumberField.vue*,
*NumberWithUnitsField.vue*,
*PasswordBaseField.vue*,
*PhoneField.vue*,
*PhotosUploadField.vue*,
*PhotoUploadField.vue*,
*RadioBlockField.vue*,
*SelectField.vue*,
*SelectMembershipPlanField.vue*,
*SelectPaymentMethodField.vue*,
*ServiceCheckboxField.vue*,
*TextAreaField.vue*,
*TextField.vue*,
*YearField.vue*,
*ZipCodeField.vue*.

Каждый вариант **Field-компонента** отличается по функциональности взаимодействия с пользователем. Часть из этих вариантов использует html input, часть — выпадающий список, блок чекбоксов и т.п. Также есть отличия в настройках масок, и других технологий управления.

## Настройки Field-компонентов

Кроме настроек, связанных с характером вводимой величины, **Field-компонент** требует настроек, связанных с конкретным параметром модели. Например, нужно указать дату получения водительских прав. В этом случае будет использоваться **Field-компонент** *DateField*. При этом, он должен ограничить диапазон используемых дат только прошедшими датами. Напротив, для даты окончания срока действия прав допустимы только будущие даты.

**Field-компонент** настраивается под конкретный параметр модели с помощью 3-х уровней настроек:

1-й уровень — уровень по умолчанию, срабатывает, когда не указаны настройки на других уровнях. Этот уровень определён в самом компоненте. Такие настройки будут одинаковыми для всех полей, которые используют данный **Field-компонент**.

2-й уровень определён индивидуально для каждого параметра модели. Настройки этого уровня помещены в файл *components/form/data/formFieldPresets.ts* . При рендеринге **Field-компонент** обращается к этому файлу и берёт оттуда соответствующие настройки. Такие настройки будут одинаковыми для одного и того же параметра модели, размещённого на разных формах. Эти настройки имеют более высокий приоритет, чем настройки **Field-компонента** по умолчанию.

3-й уровень определён в свойствах самого **Field-компонента** . Иногда необходимо в поле формы, связанное с одним и тем же параметром модели, внести некоторые особенности, связанные с контекстом формы. Например, на форме регистрации в приложении в подписи для какого-то поля может помещаться дополнительная информация, которая оказывается избыточной на других формах, и показываться там не должна. Настройки, заданные в свойствах самого **Field-компонента**, имеют наивысший приоритет.

## Ключи объекта formFieldPresets

В файле *formFieldPresets.ts* хранится объект настроек полей форм. Ключами объекта служат имена полей формы, соответствующие именам параметров модели. Эти имена-ключи прописываются в свойстве *name* **Field-компонента** . Такой подход работает в большинстве случаев, но при этом возможны конфликты имён, когда поля разных объектов модели имеют одинаковые имена. Кроме того, на формах могут использоваться поля, которые напрямую не связаны ни с каким параметром модели, но их настройки однотипны для разных форм, хотя имена полей при этом могут отличаться.

Для разрешения таких конфликтов используется технология служебных имён. В этом случае для получения настроек из *formFieldPresets.ts* в **Field-компоненте** вместо *name* задаётся свойство *serviceName*, которое уже не соответствует имени поля формы и выбирается разработчиком произвольно. **Field-компонент** будет искать настройки в файле *formFieldPresets.ts* по ключу, заданному в свойстве *serviceName* при его наличии. При этом свойство *name*, если оно задано, будет проигнорировано.

Объект, найденный по ключу (*name* или *serviceName*), заданному в **Field-компоненте**, и будет пресетом, содержащим настройки этого компонента.

## Виды настроек Field-компонента

- Поле label, определяющее подпись для поля ввода.
- Настройки, определяющие отображение и поведение специфичные для каждого варианта компонента поля ввода — опции для блока чекбоксов, условия для определения доступности выбора дат и т.п.
- Настройки валидации. Эти настройки следует рассмотреть более подробно.

## Настройки валидации

Для валидации полей форм используется модуль vuelidate. Настройка валидации определяется правилами (rules), которые подключены к полю формы. Используются как встроенные правила из модуля vuelidate, так и дополнительные, которые определяются в файле lib/validators.ts . Среди правил особое место занимает правило *required*, определяющее обязательность поля. Одно и то же поле, связанное с параметром модели, на одних формах может быть обязательным, а на других — нет. То есть, формы могут быть "строгими", на которых такие поля обязательны, и "нестрогими", на которых эти поля необязательны, при этом, другие правила валидации на этих формах остаются в силе — если уж значение вводится, то оно должно вводиться корректно.

Поэтому правило *required* не привязывается к настройкам **Field-компонента**. Оно автоматически подключается к полям при инициализации формы:

```typescript
  validations() {
    // Rules from formFieldPresets will be automatically added
    // to these fields from this list,
    // except for fields from the exclusions list.
    const fieldNames = Object.keys(this.form)

    // If the field does not need validation, or validation
    // is determined by conditions, write it in this list:
    const exclusions = ['faaCertificateNumber']

    const form = setStaticFormValidation(
      fieldNames,
      this.validateRequiredRule,
      exclusions,
    )

    // Define the validation rules by condition here:
    const hasFaaCertificateNumberValidationRules =
      formFieldPresets.faaCertificateNumber.validationRules

      form.faaCertificateNumber = { ...hasFaaCertificateNumberValidationRules }

    if (this.hasFaaCertificateNumber) {
      form.faaCertificateNumber.required = required
    }

    return { form }
  }
```

Правила валидации подключаются к полям формы в функции *setStaticFormValidation()* . Если какие-то поля не являются обязательными даже на строгих формах, они должны быть помещены в массив исключений *exclusions*. Также можно обычным образом отдельно определить для полей правила, подключаемые по условию.

В некоторых случаях вместо *required* нужно использовать другое правило, которое аналогично по смыслу, но работает немного иначе. Например, в блоке чекбоксов должно быть хоть что-то выбрано (правила *hasElements*, *hasSelected*, *multiselectNotEmpty* и аналогичные). В этом случае нужно указать в пресете поле *asRequired* объект с соответствующим правилом, заменяющим *required*:

```typescript
    asRequired: { hasSelected },
```

Прочие правила валидации подключаются к **Field-компоненту** с помощью поля *validationRules* в пресете:

```typescript
    validationRules: {
      minLength: minLength(3),
      maxLength: maxLength(20),
    },
```
